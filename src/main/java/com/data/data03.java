package com.data;

/**
 * @author: wp
 * @Title: data03
 * @Description: 3-03 复杂度分析上
 * @date 2020/3/2 19:55
 */
public class data03 {
    //下面这个方法的时间该怎么估算？
    /**
    * 假设每行代码执行的时间一致，设定为单位时间，unit_time
     * 第一行和第二行执行时间为2*unit_time
     * 第三行与第四行都执行了n次，那么时间为2n*unit_time
     * 那么总体时间就是：（2n+2）*unit_time
     * 可以得到一个结论：全部代码执行时间T(n)与每行代码执行次数n成正比
    *
    */
    public static Long cal(int n){
        int i = 0;        //1
        long sum = 0;     //2
        for(;i<n;i++){    //3
            sum += i;     //4
        }
        return sum;
    }


    /**
    * 我们可以把这个规律总结成一个公式: T(n) = O( f(n) )
     * 其中，T(n) 我们已经讲过了，它表示代码执行的时间;n 表示数据规模的大小；
     * f(n) 表示每行代码执行的次数总和,因为这是一个公式，所以用 f(n) 来表示。
     * 公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比
    *  用上面的例子来说明就是T(n) = O( 2n+2 )
     *
     *  这就是 大 O 时间复杂度表示法。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，
     *  而是 表示代码执行时间随数据规模增长的变化趋势，
     *  所以，也叫作渐进时间复杂度 （asymptotic time complexity），简称时间复杂度。
     *
     *  如果n很大足够大，那么只需要保留最大量级就行 上面的例子也可以写成T(n) = O( n )
     *  如果是 T(n) = O( 2n*n+2n )可写成 T(n) = O(n*n )。
     *
     *  大 O 这种复杂度表示方法只是表示一种变化趋势。
     *  我们通常会忽略掉公式中 的常量、低阶、系数，只需要记录一个最大阶的量级就可以了
     *
     *
     *  常见的时间复杂度有 O(1)（常量阶） O(n)（线性阶） O(n^2)（平方阶）
     *  O(n^3)（立方阶） O(logN)（对数阶） O(NlogN)（指数对数阶） O(2^n)（指数阶） O(n!)(阶层阶)
     *  O(2^n) O(n!) 这两个为非多项式量级 n足够大时 性能特别差,应尽量避免
     *
     *
     *  空间复杂度，就是算法的占用空间的大小与数据规模的增长关系
     *  常见有 O(1)（常量阶） O(n)（线性阶） O(n^2)（平方阶） 其他的不常见
     *
     *
     *
     *  小结：复杂度也叫渐进复杂度,包括时间复杂度和空间复杂度,用来分析算法执行效率与数据规模之间的增长关系，
     *  可以粗略地表示，越高阶复杂度的算法，执行效率越低。
     *  常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n)。
     */



}
